
%%Программная реализация (на языке Javascript) алгоритмов
%% генерации фонда оценочных средств по математике
\section{Глава первая}
\subsection{Реализация алгоритмов на базе проекта Час ЕГЭ}
«Час ЕГЭ» — компьютерный образовательный проект, разрабатываемый при математическом факультете ВГУ в рамках «OpenSource кластера» и предназначенный для помощи учащимся старших классов подготовиться к тестовой части единого государственного экзамена.

Задания в «Час ЕГЭ» генерируются случайным образом по специализированным алгоритмам, называемых шаблонами.
Каждый из которых охватывает множество вариантов соответствующей ему задачи. Для пользователей предназначены четыре оболочки (режима работы): «Случайное задание», «Тесты на печать», «Полный тест» и «Мини-интеграция».

«Час ЕГЭ» является полностью открытым (код находится под лицензией GNU GPL 3.0) и бесплатным.
В настоящее время в проекте полностью реализованы тесты по математике с кратким ответом (бывшая «часть В»).
Планируется с течением времени включить в проект тесты по другим предметам школьной программы.

«Мини-интеграция» — это форма сотрудничества с образовательными интернет-ресурсами, при которой учебно-методический материал на странице ресурса дополняется виджетами тренажера с заданиями, соответствующими теме статьи, для возможности практического применения полученных знаний.
В настоящее время достигнуто сотрудничество с двумя образовательными ресурсами: ege-ok.ru и matematikalegko.ru.

Как было уже сказано ранее, генерация заданий при помощи шаблонов. Они состоят из нескольких : непосредственно текстового задания и программной реализации на языке JavaScript и графичсекой, при не обходимости, на основе canvas(HTML элемент, использующийся для рисования графики средствами языков программирования).

Алгоритм написания простого шаблона на основе номера 109083 Открытого Банка Заданий ЕГЭ:%%TODO:ССЫлочки
\begin{enumerate}
    \item Выбораем задания из Открытого Банка Заданий ЕГЭ. Копируем текста задания.
    \item Добавляем ответ(по умолчанию написать 0).
          \begin{verbatim}
        (function() {
	NAinfo.requireApiVersion(0, 2);
    NAtask.setTask({
        text: 'Изюм получается в процессе сушки винограда. 
        Сколько килограммов винограда потребуется для получения 
        2 килограммов изюма, если виноград содержит 90% воды,
        а изюм содержит 5% воды?',
        answers: 0,
            });
})();
        \end{verbatim}
    \item Инициализируем всех неиобходимые переменные для задачи(количество дней, участников и так далее). Присваиваем им значения при помощи функции sluchch() или slKrome(). Под ответ создаем отдельную переменную.
          \begin{verbatim}     
    (function() {
    NAinfo.requireApiVersion(0, 2);
        let ves = sluchch(10, 100);
        let pr1, pr2, answ;
        do {
            pr1 = sluchch(4, 20);
            pr2 = sluchch(70, 90);
            answ = (ves * (100 - pr1)) / (100 - pr2);
        } while (!(answ*100).isZ());
    NAtask.setTask({
        text: 'Изюм получается в процессе сушки винограда.
        Сколько килограммов винограда потребуется для получения
        2 килограммов изюма, если виноград содержит 90% воды,
        а изюм содержит 5% воды?',
        answers: 0,
                      });
              })();
            \end{verbatim}
    \item Заменяем все цифры в тексте на переменные.
    \item Обособляем(при помощи ++) слова, которые не влияют на условия задачи. Это могут быть имена, профессии, транспорт и тп.
    \item Создаём переменных, которые будет отвечать за выбранные в прошлом пункте слова, и заменяем их на переменные в тексте задачи.
          Присваиваем им массивы из подходящих на их места слов(в именительном падеже с маленькой буквы) и используем на них функцию iz().
    \item Иногда в задании выбранные слова используются в разных падежах. Для этого в проекте существует лексический модуль. Используем на склоняемых словах функцию sklonlxkand. Теперь необходимо указать падеж слов в задании.
          Также при необходимости заглавной буквы в слове используем toZagl().
    \item Если в тексте задачи присуствуют слова зависимые от числительных к ним приняется функция chislitlx().
          \begin{verbatim}
        (function() {
            'use strict';
            NAinfo.requireApiVersion(0, 2);
                let ves = sluchch(10, 100);
                let pr1, pr2, answ;
                do {
                    pr1 = sluchch(4, 20);
                    pr2 = sluchch(70, 90);
                    answ = (ves * (100 - pr1)) / (100 - pr2);
                } while (!(answ*100).isZ());
                let pair = sklonlxkand([
                ['абрикос', 'курага'],['виноград', 'изюм'],
                [
                    ['финик', 'яблоко', 'груша', 'банан', 'дыня',
                    'персик', 'инжир', 'манго', 'папайя', 'хурма',
                    'ананас', 'кокос',
                    'шиповник', 'клюква', 'барбарис', 'клубника',
                    'вишня'
                    ].iz(),
                    'сухофрукт'
                ],
            ].iz());
            NAtask.setTask({
                text: 'При сушке '+pair[0].re+' получается '
                +pair[1].ie}'+
                'Сколько килограммов'+pair[0].re+\'
                потребуется для получения 
                '+ves+' килограммов '+pair[1].re+', ' +
                'если '+pair[0].ie+' содержит '+pr2+'\% воды, 
                а '+pair[1].ie+' содержит '+pr1+'\% воды?',
                answers: answ,
            });
        })();
        \end{verbatim}
\end{enumerate}
Но не все задачи имеют линейное решение или программа не может сразу правильно вывести правильные или реальные условия.
Для их решения в проекте существует окружение retryWhileUndefined(), которое будет запускать программу стотолько раз, пока случайные переменные не будут удолетворять всем условиям.
Перезапуск осуществляется по средствам постановки условий со следущим после return.
Рассмотрим такой пример.

Алгоритм написания шаблона с изображением графика прямой:
\begin{enumerate}
    \item Для отображения рисунка необходимо дописать модуль chas2.task.modifiers.

          addCanvasIllustration(), где будут указаны высота и ширина изображения и имя рисунка.
          \begin{verbatim}
    retryWhileUndefined(function() {
	    NAinfo.requireApiVersion(0, 2);
            chas2.task.modifiers.addCanvasIllustration({
                width: 300,
                height: 300,
                paint: paint1,
            });
    return true;
    }, 100000);
    \end{verbatim}
    \item Пусть наша прямая проходит через две точки $(x_1,y_2)$ и $(x_2,y_2)$, иницилизирем их случайным образом. Теперь через них выразим коефициенты уравнения прямой $y=kx+b$.
          Для дальнейшего вычисления точек прямой напишем вспомогательную функцию f(x).
          \begin{verbatim}
    retryWhileUndefined(function() {
	    NAinfo.requireApiVersion(0, 2);
            function f(x) {
                return k * x + b;
            }
    let x1 = sluchch(-6, 6);
	    let y1 = sluchch(-7, 6);
	    let x2 = sluchch(-10, 10);
	    let y2 = sluchch(8, 20).pm();

	    let k = (y1 - y2) / (x1 - x2);
	    if (!k.isZ() && k != 0)
		    return;
	    let b = y1 - k * x1;
            chas2.task.modifiers.addCanvasIllustration({
                width: 300,
                height: 300,
                paint: paint1,
            });
	return true;
}, 100000);
    \end{verbatim}
    \item Теперь стоит удостовериться, что наша прямая видима на рисунке.
          Поэтому положим, что она имеет две целые точки на нашем рисунке. Для этого используем функцию intPoints.
          \begin{verbatim}
        retryWhileUndefined(function() {
            NAinfo.requireApiVersion(0, 2);
                function f(x) {
                    return k * x + b;
                }
            let x1 = sluchch(-6, 6);
            let y1 = sluchch(-7, 6);
            let x2 = sluchch(-10, 10);
            let y2 = sluchch(8, 20).pm();
    
            let k = (y1 - y2) / (x1 - x2);
            if (!k.isZ() && k != 0)
                return;
            let b = y1 - k * x1;

            let points = intPoints(f, {
		            minX: -5,
		            maxX: 5,
		            minY: -5.5,
		            maxY: 5.5,
		            step: 1,
	        });
	         if (points.length < 2)
		        return;
                chas2.task.modifiers.addCanvasIllustration({
                    width: 300,
                    height: 300,
                    paint: paint1,
                });
        return true;
    }, 100000);
        \end{verbatim}
    \item Приступим к изображению графика. Иницилизирем переменную paint1, как функцию function(ct). Внутри неё зададим высоту и ширину графика в пикселях.
          Изображаем координатную плоскость функцией drawCoordPlane() и сам график функцией graph9AdrawFunction(). А также отметим две целые точки по средствам graph9AmarkCircles().
          \begin{verbatim}
        retryWhileUndefined(function() {
            NAinfo.requireApiVersion(0, 2);
                function f(x) {
                    return k * x + b;
                }
            let x1 = sluchch(-6, 6);
            let y1 = sluchch(-7, 6);
            let x2 = sluchch(-10, 10);
            let y2 = sluchch(8, 20).pm();
    
            let k = (y1 - y2) / (x1 - x2);
            if (!k.isZ() && k != 0)
                return;
            let b = y1 - k * x1;

            let points = intPoints(f, {
		            minX: -5,
		            maxX: 5,
		            minY: -5.5,
		            maxY: 5.5,
		            step: 1,
	        });
	         if (points.length < 2)
		        return;
                let paint1 = function(ct) {
                    let h = 300;
                    let w = 300;
                    //Оси координат
                    ct.drawCoordPlane(w, h, {
                        hor: 1,
                        ver: 1
                    }, {
                        x1: '1',
                        y1: '1',
                        sh1: 13,
                    }, 20);
                    //График
                    ct.scale(20, -20);
                    ct.lineWidth = 0.1;
                    graph9AdrawFunction(ct, f, {
                        minX: -6.5,
                        maxX: 7,
                        minY: -7,
                        maxY: 6,
                        step: 0.05,
                    });
                    //точки
                    graph9AmarkCircles(ct, points, 2, 0.05);

                };
                chas2.task.modifiers.addCanvasIllustration({
                    width: 300,
                    height: 300,
                    paint: paint1,
                });
        return true;
    }, 100000);
        \end{verbatim}
\end{enumerate}


