
%%Программная реализация (на языке Javascript) алгоритмов
%% генерации фонда оценочных средств по математике
\section{Глава первая}
\subsection{Реализация алгоритмов на базе проекта Час ЕГЭ}
Как было уже сказано ранее, генерация заданий происходит при помощи шаблонов.
Они состоят из нескольких частей: непосредственно текстового задания, программной реализации на языке JavaScript,
графической на основе canvas\footnote{HTML элемента, использующегося для рисования графики средствами языков программирования и алгоритма решения задачи} в случае необходимости.

Алгоритм написания простого шаблона~\cite{chasi} на основе номера 109083 Открытого Банка Заданий ЕГЭ~\cite{fipi}:
\begin{enumerate}
    \item Выбираем задание из Открытого Банка Заданий ЕГЭ и копируем его текст.
    \item Добавляем ответ в поле answers (по умолчанию 0).
          \begin{lstlisting}
            (function() {
                NAinfo.requireApiVersion(0, 2);
                NAtask.setTask({
                    text: 'Изюм получается в процессе сушки винограда. Сколько килограммов винограда потребуется для получения 2 килограммов изюма, если виноград содержит 90% воды, а изюм содержит 5% воды?',
                    answers: 0,
                        });
            })();
        \end{lstlisting}
    \item Инициализируем всех необходимые переменные для задачи (вес, проценты и так далее).
          Присваиваем им значения при помощи функции \hyperlink{sluchch}{sluchch()} или
          \hyperlink{slKrome}{slKrome()}. Для хранения ответа создаём отдельную переменную.
          \begin{lstlisting}     
            (function() {
                NAinfo.requireApiVersion(0, 2);
                let ves = sluchch(10, 100);
                let pr1, pr2, answ;
                do {
                    pr1 = sluchch(4, 20);
                    pr2 = sluchch(70, 90);
                    answ = (ves * (100 - pr1)) / (100 - pr2);
                } while (!(answ * 100).isZ());
                NAtask.setTask({
                    text: 'Изюм получается в процессе сушки винограда.Сколько килограммов винограда потребуется для получения 2 килограммов изюма,если виноград содержит 90 % воды,а изюм содержит 5 % воды ? ',
                    answers: 0,
                });
            })();            
            \end{lstlisting}
    \item Заменяем все числа в тексте на переменные (при помощи ++).
    \item Обособляем слова, которые не влияют на условия задачи. Это могут быть имена, профессии, транспорт и тп.
    \item Создаём переменные, которые будет отвечать за выбранные в прошлом пункте слова, и заменяем слова на переменные в тексте задачи.
          Выбираем их значения из массивов при помощи \hyperlink{iz}{iz()}.
    \item Иногда в задании выбранные слова используются в разных падежах. Для этого в проекте существует лексический модуль. Используем на склоняемых словах функцию \hyperlink{sklonlxkand}{sklonlxkand()}. Теперь необходимо указать падеж слов в задании.
          Также при необходимости заглавной буквы в слове используем \hyperlink{toZagl}{toZagl()}.
    \item Если в тексте задачи присутствуют слова, зависимые от числительных, к ним применяется функция \hyperlink{chislitlx}{chislitlx()}.
          \begin{lstlisting}
            (function() {
                (function() {
                    'use strict';
                    NAinfo.requireApiVersion(0, 2);
                    let ves = sluchch(10, 100);
                    let pr1, pr2, answ;
                    do {
                        pr1 = sluchch(4, 20);
                        pr2 = sluchch(70, 90);
                        answ = (ves * (100 - pr1)) / (100 - pr2);
                    } while (!(answ * 100).isZ());
                    let pair = sklonlxkand([
                        ['абрикос', 'курага'],
                        ['виноград', 'изюм'],
                        [
                            ['финик', 'яблоко', 'груша', 'банан', 'дыня','персик',
                             'инжир', 'манго', 'папайя', 'хурма', 'ананас', 'кокос',
                             'шиповник', 'клюква', 'барбарис', 'клубника', 'вишня'
                            ].iz(),
                            'сухофрукт'
                        ],
                    ].iz());
                    NAtask.setTask({
                        text: 'При сушке ' + pair[0].re + ' получается ' +
                            pair[1].ie + '. Сколько килограммов ' + pair[0].re +
                            ' потребуется для получения ' +
                            ves + ' килограммов ' + pair[1].re + ', если ' +
                            pair[0].ie + ' содержит ' + pr2 + '\% воды, а ' +
                            pair[1].ie + ' содержит ' + pr1 + '\ % воды ? ',
                        answers: answ,
                    });
                })();       
         \end{lstlisting}
\end{enumerate}

Но не все задачи решаются при помощи линейного алгоритма. Тогда в коде шаблона 
используется слишком много циклов с постусловиями(или предусловиями)
Для таких случаев в проекте существует окружение retryWhileUndefined(), которое 
будет запускать программу столько раз, пока случайные переменные не будут удовлетворять всем условиям.
Перезапуск осуществляется посредством постановки условий с последующим return.
Рассмотрим такой пример.

Алгоритм написания шаблона с изображением графика прямой:
\begin{enumerate}
    \item Для отображения рисунка необходимо вызвать функцию chas2.task.modifiers.

          addCanvasIllustration(), которой передаются высота и ширина изображения и имя функции отрисовки.
          \begin{lstlisting}
            retryWhileUndefined(function() {
                NAinfo.requireApiVersion(0, 2);
                chas2.task.modifiers.addCanvasIllustration({
                    width: 300,
                    height: 300,
                    paint: paint1,
                });
                return true;
            }, 100000);         
    \end{lstlisting}
    \item Пусть наша прямая проходит через две точки $(x_1,y_1)$ и $(x_2,y_2)$. Инициализируем их координаты случайными целыми числами. Теперь через них выразим коэффициенты уравнения прямой $y=kx+b$.
          Для дальнейшего вычисления точек прямой напишем вспомогательную функцию f(x).
          \begin{lstlisting}
            retryWhileUndefined(function() {
    	NAinfo.requireApiVersion(0, 2);

    	function f(x) {
    		return k * x + b;
    	}
    	let x1 = sluchch(-6, 6);
    	let y1 = sluchch(-7, 6);
    	let x2 = sluchch(-10, 10);
    	let y2 = sluchch(8, 20).pm();

    	let k = (y1 - y2) / (x1 - x2);
    	if (!k.isZ() && k != 0)
    		return;
    	let b = y1 - k * x1;
    	chas2.task.modifiers.addCanvasIllustration({
    		width: 300,
    		height: 300,
    		paint: paint1,
    	});
    	return true;
    }, 100000);
           \end{lstlisting}
    \item Для того, чтобы уравнения нашей прямой можно было восстановить по рисунку необходимо и достаточно,
          чтобы были видны две её точки. Для поиска таких точек используем функцию \hyperlink{intPoints}{intPoints()}.
          \begin{lstlisting}
            retryWhileUndefined(function() {
                NAinfo.requireApiVersion(0, 2);
        
                function f(x) {
                    return k * x + b;
                }
                let x1 = sluchch(-6, 6);
                let y1 = sluchch(-7, 6);
                let x2 = sluchch(-10, 10);
                let y2 = sluchch(8, 20).pm();
                retryWhileUndefined(function() {
                    NAinfo.requireApiVersion(0, 2);
        
                    function f(x) {
                        return k * x + b;
                    }
                    let x1 = sluchch(-6, 6);
                    let y1 = sluchch(-7, 6);
                    let x2 = sluchch(-10, 10);
                    let y2 = sluchch(8, 20).pm();
        
                    let k = (y1 - y2) / (x1 - x2);
                    if (!k.isZ() && k != 0)
                        return;
                    let b = y1 - k * x1;
                        let points = intPoints(f, {
                            minX: -5,
                            maxX: 5,
                            minY: -5.5,
                            maxY: 5.5,
                            step: 1,
                        });
                    if (points.length < 2)
                        return;
                    chas2.task.modifiers.addCanvasIllustration({
                        width: 300,
                        height: 300,
                        paint: paint1,
                    });
                    return true;
                }, 100000);
        
                let k = (y1 - y2) / (x1 - x2);
                if (!k.isZ() && k != 0)
                    return;
                let b = y1 - k * x1;
                chas2.task.modifiers.addCanvasIllustration({
                    width: 300,
                    height: 300,
                    paint: paint1,
                });
                return true;
            }, 100000);
        \end{lstlisting}
    \item Приступим к изображению графика. Инициализируем переменную paint1 как функцию function(ct). Внутри неё зададим высоту и ширину графика в пикселях.
          Изображаем координатную плоскость функцией \hyperlink{drawCoordPlane}{drawCoordPlane()} и сам график функцией
          \hyperlink{graph9AdrawFunction}{graph9AdrawFunction()}. А также отметим две целые точки посредством \hyperlink{graph9AmarkCircles}{graph9AmarkCircles()}.
          \begin{lstlisting}
    retryWhileUndefined(function() {
	NAinfo.requireApiVersion(0, 2);

	function f(x) {
		return k * x + b;
	}
	let x1 = sluchch(-6, 6);
	let y1 = sluchch(-7, 6);
	let x2 = sluchch(-10, 10);
	let y2 = sluchch(8, 20).pm();

	let k = (y1 - y2) / (x1 - x2);
	if (!k.isZ() && k != 0)
		return;
	let b = y1 - k * x1;

	let points = intPoints(f, {
		minX: -5,
		maxX: 5,
		minY: -5.5,
		maxY: 5.5,
		step: 1,
	});
	if (points.length < 2)
		return;
	let paint1 = function(ct) {
		let h = 300;
		let w = 300;
		//Оси координат
		ct.drawCoordPlane(w, h, {
			hor: 1,
			ver: 1
		}, {
			x1: '1',
			y1: '1',
			sh1: 13,
		}, 20);
		//График
		ct.scale(20, -20);
		ct.lineWidth = 0.1;
		graph9AdrawFunction(ct, f, {
			minX: -6.5,
			maxX: 7,
			minY: -7,
			maxY: 6,
			step: 0.05,
		});
		//точки
		graph9AmarkCircles(ct, points, 2, 0.05);

	};
	chas2.task.modifiers.addCanvasIllustration({
		width: 300,
		height: 300,
		paint: paint1,
	});
	return true;
}, 100000);
        \end{lstlisting}
\end{enumerate}
\subsection{Преимущества программной генерации заданий}
На примере двух предыдущих задач были явно показано превосходство шаблонов над заданиями из Открытого Банка Заданий, а именно:
\begin{enumerate}
    \item Большое количество разнообразных задач одного типа.
    \item Простота и скорость написания шаблонов.
    \item Невозможность нахождения учащимися ответов на задачи.
    \item Возможность юмористических формулировок заданий, что понижает моральное напряжение учащихся на проверочных работах.%%Лишний повод поржать
\end{enumerate}

